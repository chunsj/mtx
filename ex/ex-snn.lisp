(in-package :mtx)

(defun fwd (input weight) ($sigmoid! ($* input weight)))
(defun dwb (delta output) ($x delta output ($- 1 output)))

;; single layer example
(let* ((X ($m '((0 0 1)
                (0 1 1)
                (1 0 1)
                (1 1 1))))
       (y ($m '(0 0 1 1) 1))
       (s ($r 3 1))
       (a 1)
       (ntr 1000))
  (time
   (loop :for i :from 0 :below ntr
      :do (let* ((l1 (fwd X s))
                 (l1d (dwb ($- l1 y) l1))
                 (ds ($* ($transpose X) l1d)))
            (setf s ($- s ($x a ds))))))
  (print ($round (fwd X s))))

(let* ((X ($m '((0 0 1)
                (0 1 1)
                (1 0 1)
                (1 1 1))))
       (y ($m '(0 0 1 1) 1))
       (s ($r 3 1))
       (a 1)
       (ntr 1000)
       (ds ($m 0 3 1)))
  (time
   (dotimes (i ntr)
     (let* ((l1 (fwd X s))
            (l1d (dwb ($- l1 y) l1)))
       ($gemm X l1d :c ds :transa T)
       ($axpy ds s :alpha (* -1 a)))))
  (print ($round (fwd X s))))

(let* ((X ($m '((0 0)
                (0 1)
                (1 0)
                (1 1))))
       (y ($m '(0 0 1 1) 1))
       (s ($r 2 1))
       (a 1)
       (ntr 1000)
       (ds ($m 0 3 1)))
  (time
   (dotimes (i ntr)
     (let* ((l1 (fwd X s))
            (l1d (dwb ($- l1 y) l1)))
       ($gemm X l1d :c ds :transa T)
       ($axpy ds s :alpha (* -1 a)))))
  (print ($round (fwd X s))))

;; two layers
(let* ((X ($m '((0 0 1)
                (0 1 1)
                (1 0 1)
                (1 1 1))))
       (y ($m '(0 1 1 0) 1))
       (s0 ($r 3 4))
       (s1 ($r 4 1))
       (a 1)
       (ntr 1000))
  (time
   (loop :for i :from 0 :below ntr
      :do (let* ((l1 (fwd X s0))
                 (l2 (fwd l1 s1))
                 (l2d (dwb ($- l2 y) l2))
                 (l1d (dwb ($* l2d ($transpose s1)) l1))
                 (ds1 ($* ($transpose l1) l2d))
                 (ds0 ($* ($transpose X) l1d)))
            (setf s0 ($- s0 ($x a ds0))
                  s1 ($- s1 ($x a ds1))))))
  (print ($round (fwd (fwd X s0) s1))))

(let* ((X ($m '((0 0 1)
                (0 1 1)
                (1 0 1)
                (1 1 1))))
       (y ($m '(0 1 1 0) 1))
       (s0 ($r 3 4))
       (s1 ($r 4 1))
       (a 1)
       (ntr 1000)
       (ds1 ($m 0 4 1))
       (ds0 ($m 0 3 4))
       (d21 ($m 0 4 4)))
  (time
   (dotimes (i ntr)
     (let* ((l1 (fwd X s0))
            (l2 (fwd l1 s1))
            (l2d (dwb ($- l2 y) l2))
            (l1d (dwb ($gemm l2d s1 :c d21 :transb T) l1)))
       ($gemm l1 l2d :c ds1 :transa T)
       ($gemm X l1d :c ds0 :transa T)
       ($axpy ds1 s1 :alpha (* -1 a))
       ($axpy ds0 s0 :alpha (* -1 a)))))
  (print ($round (fwd (fwd X s0) s1))))

(let* ((X ($m '((0 0)
                (0 1)
                (1 0)
                (1 1))))
       (y ($m '(0 1 1 0) 1))
       (s0 ($r 2 4))
       (s1 ($r 4 1))
       (a 1)
       (ntr 1000)
       (ds1 ($m 0 4 1))
       (ds0 ($m 0 2 4))
       (d21 ($m 0 4 4)))
  (time
   (dotimes (i ntr)
     (let* ((l1 (fwd X s0))
            (l2 (fwd l1 s1))
            (l2d (dwb ($- l2 y) l2))
            (l1d (dwb ($gemm l2d s1 :c d21 :transb T) l1)))
       ($gemm l1 l2d :c ds1 :transa T)
       ($gemm X l1d :c ds0 :transa T)
       ($axpy ds1 s1 :alpha (* -1 a))
       ($axpy ds0 s0 :alpha (* -1 a)))))
  (print ($round (fwd (fwd X s0) s1))))

;; relu test case
(defun fwd (input weight) ($relu ($* input weight)))
(defun dwb (delta output) ($map (lambda (d e) (if (> e 0) d 0.0)) delta output))

(let* ((X ($m '((0 0)
                (0 1)
                (1 0)
                (1 1))))
       (y ($m '(0 1 1 0) 1))
       (s0 ($x ($rn 2 4) (sqrt (/ 2.0 2.0))))
       (s1 ($x ($rn 4 1) (sqrt (/ 2.0 4.0))))
       (a 0.1)
       (ntr 1000)
       (ds1 ($m 0 4 1))
       (ds0 ($m 0 2 4))
       (d21 ($m 0 4 4)))
  ;; working weights
  ;; (setf s0 ($m '((6.42e-1    3.42e-1   -7.26e-1    9.81e-1)
  ;;                (5.76e-2   -4.99e-1   -3.82e-1    4.85e-1))))
  ;; (setf s1 ($m '(5.87e-1
  ;;                1.12e+0
  ;;                -9.92e-1
  ;;                1.15e+0)
  ;;              1))
  (print s0)
  (print s1)
  (print (/ ($sum s0) (* 2 4)))
  (print (/ ($sum s1) 4))
  (time
   (dotimes (i ntr)
     (let* ((l1 (fwd X s0))
            (l2 (fwd l1 s1))
            (delta2 ($- l2 y))
            (l2d (dwb delta2 l2))
            (delta1 ($gemm l2d s1 :c d21 :transb T))
            (l1d (dwb delta1 l1)))
       ($gemm l1 l2d :c ds1 :transa T)
       ($gemm X l1d :c ds0 :transa T)
       ($axpy ds1 s1 :alpha (* -1 a))
       ($axpy ds0 s0 :alpha (* -1 a)))))
  (print (fwd (fwd X s0) s1))
  (print ($round (fwd (fwd X s0) s1))))
