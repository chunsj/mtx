(in-package :mtx)

(declaim (optimize (speed 3) (safety 0) (debug 1)))

(declaim (inline $gemm))
(defun $gemm (a b &key (alpha 1.0) (beta 0.0) (c nil) (transa nil) (transb nil))
  (let* ((nra (if transa ($ncol a) ($nrow a)))
         (nca (if transa ($nrow a) ($ncol a)))
         (ncb (if transb ($nrow b) ($ncol b)))
         (c (or c ($mx ($vx (* nra ncb)) :nrow nra :ncol ncb)))
         (m nra)
         (n ncb)
         (k nca)
         (lda (if transa k m))
         (ldb (if transb n k))
         (ldc m)
         (transa (if transa "T" "N"))
         (transb (if transb "T" "N"))
         (ax ($fnv a))
         (bx ($fnv b))
         (cx ($fnv c)))
    (%sgemm transa transb m n k
            alpha
            ax lda bx ldb
            beta
            cx ldc)
    c))

(defun $mm (a b &key (alpha 1.0) (beta 0.0) (c nil))
  ($gemm a b :alpha alpha :beta beta :c c))

(defun broadcast-vector (m n)
  (let ((nr ($nrow m))
        (nc ($ncol m))
        (mvs ($fnv m)))
    (cond ((= 1 nr) (let* ((nnr n)
                           (vs ($vx (* nnr nc)))
                           (pv ($ptr vs))
                           (pmv ($ptr mvs)))
                      (dotimes (j nc)
                        (dotimes (i nnr)
                          (setf ($prf pv (+ (* nnr j) i)) ($prf pmv j))))
                      ($mx vs :nrow nnr :ncol nc)))
          ((= 1 nc) (let* ((nnc n)
                           (vs ($vx (* nr nnc)))
                           (pv ($ptr vs))
                           (pmv ($ptr mvs)))
                      (dotimes (j nnc)
                        (dotimes (i nr)
                          (setf ($prf pv (+ (* nr j) i)) ($prf pmv i))))
                      ($mx vs :nrow nr :ncol nnc))))))

(declaim (inline $copy))
(defun $copy (a b &key (incx 1) (incy 1))
  (let ((n ($size a)))
    (%scopy n ($fnv a) incx ($fnv b) incy)))

(defun $dup (a)
  (let* ((n ($size a))
         (b ($mx ($vx n) :nrow ($nrow a) :ncol ($ncol a))))
    ($copy a b)
    b))

(declaim (inline $axpy))
(defun $axpy (a b &key (alpha 1.0) (incx 1) (incy 1))
  (let* ((n ($size a)))
    (%saxpy n alpha ($fnv a) incx ($fnv b) incy)
    b))

(defun $m+ (a b &key (c nil))
  (let ((c (or c ($dup b))))
    ($axpy a c)
    c))

(defun $m+! (a b)
  ($axpy a b)
  b)

(defun $m- (a b &key (c nil))
  (let ((c (or c ($dup a))))
    ($axpy b c :alpha -1.0)
    c))

(declaim (inline $scal))
(defun $scal (alpha x &key (incx 1))
  (let ((n ($size x)))
    (%sscal n alpha ($fnv x) incx)
    x))

(defun $m* (alpha x &key (y nil))
  (let ((y (or y ($dup x))))
    ($scal alpha y)
    y))

(defun $m.* (a b &key (c nil))
  (let* ((c (or c ($dup a)))
         (n ($size c))
         (pa ($ptr a))
         (pb ($ptr b))
         (pc ($ptr c)))
    (dotimes (i n)
      (setf ($prf pc i) (* ($prf pa i) ($prf pb i))))
    c))

(defun $m.*! (a b)
  (let* ((n ($size a))
         (pa ($ptr a))
         (pb ($ptr b)))
    (dotimes (i n)
      (setf ($prf pb i) (* ($prf pa i) ($prf pb i))))
    b))

(defgeneric multiply (a b))

(defmethod multiply ((a NUMBER) (b NUMBER)) (* a b))

(defmethod multiply ((a NUMBER) (b MX)) ($m* a b))
(defmethod multiply ((a MX) (b NUMBER)) ($m* b a))

(defmethod multiply ((a MX) (b MX)) ($mm a b))

(defun $* (&rest args)
  (cond ((= (length args) 0) 1)
        (T (reduce #'multiply args))))

(defgeneric hadamard-multiply (a b))

(defmethod hadamard-multiply ((a NUMBER) (b NUMBER)) (* a b))

(defmethod hadamard-multiply ((a NUMBER) (b MX)) ($m* a b))
(defmethod hadamard-multiply ((a MX) (b NUMBER)) ($m* b a))

(defmethod hadamard-multiply ((a MX) (b MX))
  (cond ((and (= ($size a) ($size b)) ($matrix? a) ($matrix? b)) ($m.* a b))
        ((and ($row-vector? a) (= ($ncol a) ($ncol b))) ($m.* (broadcast-vector a ($nrow b)) b))
        ((and ($column-vector? a) (= ($nrow a) ($nrow b))) ($m.* (broadcast-vector a ($ncol b)) b))
        ((and ($row-vector? b) (= ($ncol b) ($ncol a))) ($m.* (broadcast-vector b ($nrow a)) a))
        ((and ($column-vector? b) (= ($nrow b) ($nrow a))) ($m.* (broadcast-vector b ($ncol a)) a))
        ((and ($vector? a) ($vector? b)) (cond ((and ($column-vector? a)
                                                     ($row-vector? b))
                                                ($m.* (broadcast-vector a ($ncol b))
                                                      (broadcast-vector b ($nrow a))))
                                               ((and ($row-vector? a)
                                                     ($column-vector? b))
                                                ($m.* (broadcast-vector a ($nrow b))
                                                      (broadcast-vector b ($ncol a))))))))

(defun $x (&rest args)
  (cond ((= (length args) 0) 1)
        (T (reduce #'hadamard-multiply args))))

(defgeneric add (a b))

(defmethod add ((a NUMBER) (b NUMBER)) (+ a b))

(defun broadcast-number (v nr nc)
  ($mx ($vx (* nr nc) :initial-value v) :nrow nr :ncol nc))

(defmethod add ((a NUMBER) (b MX))
  (let ((vs ($fnv b))))
  ($m+ (broadcast-number a ($nrow b) ($ncol b)) b))
(defmethod add ((a MX) (b NUMBER)) (add b a))

(defmethod add ((a MX) (b MX))
  (cond ((and (= ($size a) ($size b)) ($matrix? a) ($matrix? b)) ($m+ a b))
        ((and ($row-vector? a) (= ($ncol a) ($ncol b))) ($m+ (broadcast-vector a ($nrow b)) b))
        ((and ($column-vector? a) (= ($nrow a) ($nrow b))) ($m+ (broadcast-vector a ($ncol b)) b))
        ((and ($row-vector? b) (= ($ncol b) ($ncol a))) ($m+ (broadcast-vector b ($nrow a)) a))
        ((and ($column-vector? b) (= ($nrow b) ($nrow a))) ($m+ (broadcast-vector b ($ncol a)) a))
        ((and ($vector? a) ($vector? b)) (cond ((and ($column-vector? a)
                                                     ($row-vector? b))
                                                ($m+ (broadcast-vector a ($ncol b))
                                                     (broadcast-vector b ($nrow a))))
                                               ((and ($row-vector? a)
                                                     ($column-vector? b))
                                                ($m+ (broadcast-vector a ($nrow b))
                                                     (broadcast-vector b ($ncol a))))))))

(defun $+ (&rest args)
  (cond ((= (length args) 0) 0)
        (T (reduce #'add args))))

(defgeneric subtract (a b))

(defmethod subtract ((a NUMBER) (b NUMBER)) (- a b))

(defmethod subtract ((a NUMBER) (b MX)) ($m- (broadcast-number a ($nrow b) ($ncol b)) b))
(defmethod subtract ((a MX) (b NUMBER)) ($m- a (broadcast-number b ($nrow a) ($ncol a))))

(defmethod subtract ((a MX) (b MX))
  (cond ((and (= ($size a) ($size b)) ($matrix? a) ($matrix? b)) ($m- a b))
        ((and ($row-vector? a) (= ($ncol a) ($ncol b))) ($m- (broadcast-vector a ($nrow b)) b))
        ((and ($column-vector? a) (= ($nrow a) ($nrow b))) ($m- (broadcast-vector a ($ncol b)) b))
        ((and ($row-vector? b) (= ($ncol b) ($ncol a))) ($m- a (broadcast-vector b ($nrow a))))
        ((and ($column-vector? b) (= ($nrow b) ($nrow a))) ($m- a (broadcast-vector b ($ncol a))))
        ((and ($vector? a) ($vector? b)) (cond ((and ($column-vector? a)
                                                     ($row-vector? b))
                                                ($m- (broadcast-vector a ($ncol b))
                                                     (broadcast-vector b ($nrow a))))
                                               ((and ($row-vector? a)
                                                     ($column-vector? b))
                                                ($m- (broadcast-vector a ($nrow b))
                                                     (broadcast-vector b ($ncol a))))))))

(defun $- (&rest args)
  (cond ((= 1 (length args)) ($x -1 (car args)))
        (T (reduce #'subtract args))))

(defgeneric divide (a b))

(defmethod divide ((a NUMBER) (b NUMBER)) (/ a b))

(defun 1/n (m)
  (let ((n ($dup m)))
    (loop :for i :from 0 :below ($size m)
       :do (setf ($ref ($fnv n) i) (/ 1.0 ($ref ($fnv m) i))))
    n))

(defmethod divide ((a NUMBER) (b MX)) (hadamard-multiply a (1/n b)))
(defmethod divide ((a MX) (b NUMBER)) (hadamard-multiply a (/ 1.0 b)))

(defmethod divide ((a MX) (b MX)) (hadamard-multiply a (1/n b)))

(defun $/ (&rest args)
  (cond ((= 1 (length args)) (divide 1 (car args)))
        (T (reduce #'divide args))))

(defgeneric $sum (m &key axis))

(defmethod $sum ((m NUMBER) &key axis) (declare (ignore axis)) m)
(defmethod $sum ((m LIST) &key axis)
  (declare (ignore axis))
  (loop :for i :from 0 :below ($count m) :sum (elt m i)))
(defmethod $sum ((m ARRAY) &key axis)
  (declare (ignore axis))
  (loop :for i :from 0 :below ($count m) :sum (elt m i)))
(defmethod $sum ((m MX) &key axis)
  (cond ((null axis) (let ((vs ($fnv m)))
                       (loop :for i :from 0 :below ($count vs) :sum ($ref vs i))))
        ((eq axis :row) (let* ((nr ($nrow m))
                               (nc ($ncol m))
                               (nm ($m 0 nr 1)))
                          (loop :for i :from 0 :below nr
                             :do (setf ($ nm i 0)
                                       (loop :for j :from 0 :below nc :sum ($ m i j))))
                          nm))
        (T (let* ((nr ($nrow m))
                  (nc ($ncol m))
                  (nm ($m 0 1 nc)))
             (loop :for j :from 0 :below nc
                :do (setf ($ nm 0 j)
                          (loop :for i :from 0 :below nr :sum ($ m i j))))
             nm))))

(defgeneric $max (m &key))

(defmethod $max ((m NUMBER) &key) m)
(defmethod $max ((m LIST) &key) (loop :for i :from 0 :below ($count m) :maximize (elt m i)))
(defmethod $max ((m ARRAY) &key) (loop :for i :from 0 :below ($count m) :maximize (elt m i)))
(defmethod $max ((m MX) &key (axis nil))
  (cond ((null axis) (let ((vs ($fnv m)))
                       (loop :for i :from 0 :below ($count vs) :maximize ($ref vs i))))
        ((eq axis :row) (let ((r ($m 0 ($nrow m) 1)))
                          (loop :for i :from 0 :below ($nrow m)
                             :do (setf ($ r i 0)
                                       (loop :for j :from 0 :below ($ncol m)
                                          :maximize ($ m i j))))
                          r))
        ((eq axis :column) (let ((r ($m 0 1 ($ncol m))))
                             (loop :for j :from 0 :below ($ncol m)
                                :do (setf ($ r 0 j)
                                          (loop :for i :from 0 :below ($nrow m)
                                             :maximize ($ m i j))))
                             r))))

(defgeneric $min (m &key))

(defmethod $min ((m NUMBER) &key) m)
(defmethod $min ((m LIST) &key) (loop :for i :from 0 :below ($count m) :minimize (elt m i)))
(defmethod $min ((m ARRAY) &key) (loop :for i :from 0 :below ($count m) :minimize (elt m i)))
(defmethod $min ((m MX) &key (axis nil))
  (cond ((null axis) (let ((vs ($fnv m)))
                       (loop :for i :from 0 :below ($count vs) :minimize ($ref vs i))))
        ((eq axis :row) (let ((r ($m 0 ($nrow m) 1)))
                          (loop :for i :from 0 :below ($nrow m)
                             :do (setf ($ r i 0)
                                       (loop :for j :from 0 :below ($ncol m)
                                          :minimize ($ m i j))))
                          r))
        ((eq axis :column) (let ((r ($m 0 1 ($ncol m))))
                             (loop :for j :from 0 :below ($ncol m)
                                :do (setf ($ r 0 j)
                                          (loop :for i :from 0 :below ($nrow m)
                                             :minimize ($ m i j))))
                             r))))

(defun $xwpb (x w b)
  (let ((c (broadcast-vector b ($nrow x))))
    ($mm x w :beta 1.0 :c c)
    c))

(defun $map (function matrix &rest matrices)
  (if matrices
      (let* ((nr ($nrow matrix))
             (nc ($ncol matrix))
             (n (* nr nc))
             (mptr (fnv-float-foreign-pointer ($fnv matrix)))
             (mptrs (mapcar (lambda (m) (fnv-float-foreign-pointer ($fnv m))) matrices))
             (x ($mx ($vx n) :nrow nr :ncol nc))
             (xptr (fnv-float-foreign-pointer ($fnv x))))
        (dotimes (i n)
          (setf (fnv-float-ptr-ref xptr i)
                (apply #'funcall function
                       (fnv-float-ptr-ref mptr i)
                       (mapcar (lambda (p) (fnv-float-ptr-ref p i)) mptrs))))
        x)
      (let* ((nr ($nrow matrix))
             (nc ($ncol matrix))
             (n (* nr nc))
             (mptr (fnv-float-foreign-pointer ($fnv matrix)))
             (x ($mx ($vx n) :nrow nr :ncol nc))
             (xptr (fnv-float-foreign-pointer ($fnv x))))
        (dotimes (i n)
          (setf (fnv-float-ptr-ref xptr i) (funcall function (fnv-float-ptr-ref mptr i))))
        x)))

(defun $map! (function matrix &rest matrices)
  (if matrices
      (let* ((nr ($nrow matrix))
             (nc ($ncol matrix))
             (n (* nr nc))
             (mptr (fnv-float-foreign-pointer ($fnv matrix)))
             (mptrs (mapcar (lambda (m) (fnv-float-foreign-pointer ($fnv m))) matrices))
             (x (car (last matrices)))
             (xptr (car (last mptrs))))
        (dotimes (i n)
          (setf (fnv-float-ptr-ref xptr i)
                (apply #'funcall function
                       (fnv-float-ptr-ref mptr i)
                       (mapcar (lambda (p) (fnv-float-ptr-ref p i)) mptrs))))
        x)
      (let* ((nr ($nrow matrix))
             (nc ($ncol matrix))
             (n (* nr nc))
             (mptr (fnv-float-foreign-pointer ($fnv matrix)))
             (x matrix)
             (xptr mptr))
        (dotimes (i n)
          (setf (fnv-float-ptr-ref xptr i) (funcall function (fnv-float-ptr-ref mptr i))))
        x)))

(defgeneric $iamax (m))

(defmethod $iamax ((n NUMBER)) nil)
(defmethod $iamax ((m MX))
  (let ((idx (1- (%isamax ($size m) ($fnv m) 1)))
        (nr ($nrow m)))
    (multiple-value-bind (div rem) (floor idx nr)
      (list idx (list rem div)))))

(defgeneric $imax (m &key))

(defmethod $imax ((n NUMBER) &key) nil)
(defmethod $imax ((m MX) &key axis)
  (cond ((null axis) (let* ((x ($ m 0 0))
                            (xi 0)
                            (xj 0))
                       (loop :for j :from 0 :below ($ncol m)
                          :do (loop :for i :from 0 :below ($nrow m)
                                 :do (when (> ($ m i j) x)
                                       (setf x ($ m i j))
                                       (setf xi i xj j))))
                       (list xi xj)))
        ((eq axis :row) (let* ((nr ($nrow m))
                               (nc ($ncol m))
                               (nm ($m 0 nr 1)))
                          (loop :for i :from 0 :below nr
                             :do (setf ($ nm i 0)
                                       (let ((x ($ m i 0))
                                             (xj 0))
                                         (loop :for j :from 0 :below nc
                                            :do (when (> ($ m i j) x)
                                                  (setf x ($ m i j))
                                                  (setf xj j)))
                                         (* 1.0 xj))))
                          nm))
        ((eq axis :column) (let* ((nr ($nrow m))
                                  (nc ($ncol m))
                                  (nm ($m 0 1 nc)))
                             (loop :for j :from 0 :below nc
                                :do (setf ($ nm 0 j)
                                          (let ((x ($ m 0 j))
                                                (xi 0))
                                            (loop :for i :from 0 :below nr
                                               :do (when (> ($ m i j) x)
                                                     (setf x ($ m i j))
                                                     (setf xi i)))
                                            (* 1.0 xi))))
                             nm))))

(defgeneric $imin (m &key))

(defmethod $imin ((n NUMBER) &key) nil)
(defmethod $imin ((m MX) &key axis)
  (cond ((null axis) (let* ((x ($ m 0 0))
                            (xi 0)
                            (xj 0))
                       (loop :for j :from 0 :below ($ncol m)
                          :do (loop :for i :from 0 :below ($nrow m)
                                 :do (when (< ($ m i j) x)
                                       (setf x ($ m i j))
                                       (setf xi i xj j))))
                       (list xi xj)))
        ((eq axis :row) (let* ((nr ($nrow m))
                               (nc ($ncol m))
                               (nm ($m 0 nr 1)))
                          (loop :for i :from 0 :below nr
                             :do (setf ($ nm i 0)
                                       (let ((x ($ m i 0))
                                             (xj 0))
                                         (loop :for j :from 0 :below nc
                                            :do (when (< ($ m i j) x)
                                                  (setf x ($ m i j))
                                                  (setf xj j)))
                                         (* 1.0 xj))))
                          nm))
        ((eq axis :column) (let* ((nr ($nrow m))
                                  (nc ($ncol m))
                                  (nm ($m 0 1 nc)))
                             (loop :for j :from 0 :below nc
                                :do (setf ($ nm 0 j)
                                          (let ((x ($ m 0 j))
                                                (xi 0))
                                            (loop :for i :from 0 :below nr
                                               :do (when (< ($ m i j) x)
                                                     (setf x ($ m i j))
                                                     (setf xi i)))
                                            (* 1.0 xi))))
                             nm))))

(defun $argmax (m &key (axis :row))
  (cond ((eq axis :row) ($imax m :axis :row))
        (T ($imax m :axis :column))))

(defun $argmin (m &key (axis :row))
  (cond ((eq axis :row) ($imin m :axis :row))
        (T ($imin m :axis :column))))

(defgeneric $mean (m &key))

(defmethod $mean ((n NUMBER) &key) n)
(defmethod $mean ((m MX) &key axis)
  (cond ((null axis) (/ ($sum m) ($size m)))
        ((eq axis :row) (let* ((nr ($nrow m))
                               (nc ($ncol m))
                               (nm ($m 0 nr 1)))
                          (loop :for i :from 0 :below nr
                             :do (setf ($ nm i 0)
                                       (/ (loop :for j :from 0 :below nc :sum ($ m i j))
                                          nc)))
                          nm))
        ((eq axis :column) (let* ((nr ($nrow m))
                                  (nc ($ncol m))
                                  (nm ($m 0 1 nc)))
                             (loop :for j :from 0 :below nc
                                :do (setf ($ nm 0 j)
                                          (/ (loop :for i :from 0 :below nr :sum ($ m i j))
                                             nr)))
                             nm))))

(defun vofm (m nr nc p i j)
  (let ((im (- i p))
        (jm (- j p)))
    (if (or (< im 0) (>= im nr) (< jm 0) (>= jm nc))
        0.0
        ($ m 0 (+ (* im nr) jm)))))

(defun $convolute-dim (nr nc fs &key (padding 0) (stride 1))
  (let ((cr (1+ (/ (+ (- nr fs) (* 2 padding)) stride)))
        (cc (1+ (/ (+ (- nc fs) (* 2 padding)) stride))))
    (list cr cc)))

(defun $convolute (m nr nc f fs &key (b 0.0) (padding 0) (stride 1))
  ;; m and f should be in the form of row vector
  (let ((cr (1+ (/ (+ (- nr fs) (* 2 padding)) stride)))
        (cc (1+ (/ (+ (- nc fs) (* 2 padding)) stride))))
    (assert (and (integerp cr) (integerp cc))
            nil
            "dimension mismatched")
    (when (and (integerp cr) (integerp cc))
      (let* ((mr (+ nr (* 2 padding)))
             (mc (+ nc (* 2 padding)))
             (cm ($zeros 1 (* cr cc)))
             (fd (1- fs))
             (bf (* 1.0 b)))
        (loop :for i :from 0 :below mr :by stride :while (< (+ i fd) mr) :do
          (loop :for j :from 0 :below mc :by stride :while (< (+ j fd) mc) :do
            (let ((e 0))
              (loop :for ik :from 0 :below fs :do
                (loop :for jk :from 0 :below fs :do
                  (let ((mv (vofm m nr nc padding (+ i ik) (+ j jk)))
                        (fv (vofm f fs fs 0 ik jk)))
                    (incf e (* mv fv)))))
              (setf ($ cm 0 (+ (* cc i) j)) (+ e bf)))))
        cm))))

(defun $conv2d (input w)
  (let* ((N1 ($nrow input))
         (N2 ($ncol input))
         (m ($nrow w))
         (K1 (+ N1 (- m) 1))
         (K2 (+ N2 (- m) 1))
         (output ($zeros K1 K2)))
    (loop :for i :from 0 :below K1 :do
      (loop :for j :from 0 :below K2 :do
        (let ((m-1 (- m 1)))
          (setf ($ output i j)
                (loop :for a :from 0 :to m-1
                      :sum (loop :for b :from 0 :to m-1
                                 :sum (* ($ w a b) ($ input (+ i a) (+ j b)))))))))
    output))

(defun $maxpool (input m)
  (let* ((N1 ($nrow input))
         (N2 ($ncol input))
         (K1 (+ N1 (- m) 1))
         (K2 (+ N2 (- m) 1))
         (output ($zeros K1 K2)))
    (loop :for i :from 0 :below K1 :do
      (loop :for j :from 0 :below K2 :do
        (let ((m-1 (- m 1)))
          (setf ($ output i j)
                (loop :for a :from 0 :to m-1
                      :maximize (loop :for b :from 0 :to m-1
                                      :maximize ($ input (+ i a) (+ j b))))))))
    output))

(defun $avgpool (input m)
  (let* ((N1 ($nrow input))
         (N2 ($ncol input))
         (K1 (+ N1 (- m) 1))
         (K2 (+ N2 (- m) 1))
         (1/m*m (/ 1.0 (* m m)))
         (output ($zeros K1 K2)))
    (loop :for i :from 0 :below K1 :do
      (loop :for j :from 0 :below K2 :do
        (let ((m-1 (- m 1)))
          (setf ($ output i j)
                (* 1/m*m (loop :for a :from 0 :to m-1
                               :sum (loop :for b :from 0 :to m-1
                                          :sum ($ input (+ i a) (+ j b)))))))))
    output))
